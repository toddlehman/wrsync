#!/usr/bin/perl -w
#===============================================================================
# RSYNC WRAPPER
#
# This program improves the interface of the standard rsync tool by invoking it
# as a subprocess and modifying its output in the following ways:
#
# 1.  The multi-column information generated by rsync's --itemize-changes
#     option is boiled down to four cases:
#
#        ·  Trivial timestamp change (directories only)
#        ◦  Metadata update (any type)
#        •  Content transfer or creation (file, directory, link, etc.)
#        ⨉  Deletion (any type)
#
# 2.  When synchronizing, an itemization pass is always performed to calculate
#     the total size of the payload to be transferred.  This total is then used
#     during the synchronization pass to give live (up-to-the-second) progress
#     updates of not only the current file but the entire payload.  For example,
#     the following line shows that 18% of the 271st of 327 items has been thus
#     far transferred, with a total completion of 92.63% of 38.24 GB, and an
#     overall rate of 51.08 MB/s, with an estimated time of completion in
#     approximately 6 minutes, at approximately 2:45pm:
#
#        18% of 271 of 327   92.63% of 38.24 GB   51.08 MB/s   2:45pm (5m 49s)
#
# 3.  After synchronization is complete, a short summary is given.  For example,
#     the following line (split into two lines here) shows that 38.24 GB of a
#     possible 424.8 GB were transferred or altered, consisting of 327 of a
#     possible 3,697 items, at an overall rate of 51.23 MB/s, in approximately
#     12.5 minutes, plus a summary indicating that 253 items were transferred,
#     12 items were updated, and 6 items were deleted:
#
#        38.24 GB (of 424.8 GB) in 327 (of 3,697) items in 12m 26s (51.23 MB/s):
#          · 5  ◦ 12  • 248  ⨉ 6
#         
# This program is mostly a drop-in replacement for rsync, but has the following
# notable differences:
#
#    --local-rsync-path=PATH
#          Overrides the default path of the rsync program on the local system.
#          This is offered mainly for testing and should rarely be necessary.
#
#    --remote-rsync-path=PATH
#          Overrides the default path of the rsync program on the remote system.
#          This is offered mainly for testing and should rarely be necessary.
#
#    --debug
#          Enables voluminous output showing the contents of the rsync output
#          as well as other information.
#
#    --compare-only
#          Performs a single-pass, silent comparison of the source and
#          destination, setting the exit value of this program as follows:
#              0  Source and destination are identical.
#              1  Source and destination are not identical.
#          Note that "identical" here does not necessarily mean that the source
#          and destination are truly identical; it merely means that rsync
#          considers them to be identical after applying filter rules
#          (inclusions, exclusions, uid/gid mapping, etc.).  In short,
#          "identical" here means that if rsync were invoked to perform a
#          synchronization, it would have nothing to do.
#
#    --itemize-changes
#          Enables itemization mode.  Causes filenames (and directories, etc.)
#          to be listed as they are transferred or updated, one per line, as
#          discussed above in point number 3.  Note:  This mode is enabled by
#          default, in contrast with rsync, where it is disabled by default.
#
#    --no-itemize-changes
#          Disables itemization mode.  With this option, output of this program
#          is minimal.
#
#    --progress
#          Enables progress mode.  Causes live updates to be shown (using lines
#          ending in \r) during file transfer, as discussed above in point
#          number 2.  Note:  This mode is enabled by default, in contrast with
#          rsync, where it is disabled by default.
#
#    --no-progress
#          Disables progress mode.  With this option, no way of seeing the
#          estimated completion time or amount of work to be performed is
#          available to the user until the program completes.  Note that the
#          post-transfer summary described in point number 3 above is shown
#          regardless of the --progress option, unless --no-summary is
#          specified.
#
#    --summary
#          Enables the output of a summary line upon completion of work.  This
#          is enabled by default.
#
#    --no-summary
#          Disables output of a summary line.
#
#    --dry-run, -n
#          Perform only a single pass to determine the workload and prints a
#          summary as described in point number 3 above.  If no changes are
#          necessary between the source and destination, then "No changes" is
#          the only output.  (Warning:  In scripts, do not rely on the textual
#          output of the words "No changes," as the output may change.  Instead,
#          use the --compare-only option and examine the exit value.)
#
# NOTE:  rsync version 3.1.3 or higher is assumed.
#
# TODD S. LEHMAN, DECEMBER 2019

#-------------------------------------------------------------------------------
use strict;
use utf8;

#-------------------------------------------------------------------------------
binmode(STDOUT, ':utf8');
$| = 1;

#-------------------------------------------------------------------------------
# ISOLATE PROGRAM NAME FOR USE IN OUTPUT MESSAGES

(my $PROGRAM_NAME = $0) =~ s{^.*/}{};

#-------------------------------------------------------------------------------
# GLOBAL VARIABLES (COMMAND-LINE OPTIONS)

my $DEBUG_MODE       = 0;
my $COMPARISON_MODE  = 0;
my $DRY_RUN_MODE     = 0;
my $VERBOSE_MODE     = 0;
my $ITEMIZE_MODE     = 1;
my $PROGRESS_MODE    = 1;
my $SUMMARY_MODE     = 1;

#-------------------------------------------------------------------------------
# RSYNC PATH
#
# MacOS X up through 10.15 ships with rsync version 2.6.9.  This program
# requires at least version 3.1.3, which is easily installed via MacPorts or
# Homebrew.  This program currently *assumes* that version 3.1.3 is installed
# via MacPorts at the following location.  This should be revisited in the
# future so that (1) the version can be verified/validated at runtime and (2)
# the proper rsync can be found on-the-fly by querying various locations.
my $LOCAL_RSYNC_PATH  = "/opt/local/bin/rsync";
my $REMOTE_RSYNC_PATH = "/opt/local/bin/rsync";

#-------------------------------------------------------------------------------
# PRINT VERBOSE MESSAGE

sub verbose_message ($)
{
  my ($message) = @_;
  if ($VERBOSE_MODE)
    { print "%s\n"; }
  return;
}

#-------------------------------------------------------------------------------
# PRINT DEBUGGING MESSAGE

sub debug_message ($;$)
{
  my ($message, $display_eol) = @_;
  if ($DEBUG_MODE)
  {
    if ($display_eol)
    {
      $message =~ s{\r$}{\\r};
      $message =~ s{\n$}{\\n};
    }
    print "$message\n";
  }
  return;
}

#-------------------------------------------------------------------------------
# PRINT GENERAL ERROR MESSAGE

sub error_message ($)
{
  my ($message) = @_;
  if ($message =~ s{^(\n+)}{})
    { print STDERR $1; }
  print STDERR "$PROGRAM_NAME: $message\n";
  return;
}

#-------------------------------------------------------------------------------
# PRINT GENERAL ERROR MESSAGE AND HALT PROGRAM WITH ERROR INDICATOR

sub error_message_exit ($)
{
  my ($message) = @_;
  error_message($message);
  exit 1;
}

#-------------------------------------------------------------------------------
# GET EPOCH TIME WITH SUB-SECOND ACCURACY

sub get_time ()
{
  my $time;
  eval
  {
    use Time::HiRes qw(gettimeofday);
    $time = gettimeofday();
  }
  or do
  {
    $time = time();
  };
  return $time;
}

#-------------------------------------------------------------------------------
# HANDLE SIGNALS

my $HALT_REQUESTED = 0;
my $time_start = undef;
my $time_suspended = undef;

sub format_future_time ($);    # (Forward delcaration)
sub format_time_interval ($);  # (Forward delcaration)

$::SIG{INT} = sub
{
  $HALT_REQUESTED = 1;
  error_message(sprintf("\nINTERRUPTED AT %s",
                        format_future_time(get_time())));
  return;
};

#$::SIG{TERM} = sub
#{
#  $HALT_REQUESTED = 1;
#  error_message(sprintf("\nTERMINATION REQUESTED AT %s",
#                        format_future_time(get_time())));
#  $::SIG{TERM} = "DEFAULT";
#  kill 'TERM', $$;
#  return;
#};

$::SIG{TSTP} = sub
{
  $time_suspended = get_time();
  error_message(sprintf("\nSUSPENDED AT %s",
                        format_future_time($time_suspended)));
  kill 'STOP', $$;
  return;
};

$::SIG{CONT} = sub
{
  my $time_resumed = get_time();
  if (defined($time_suspended))
  {
    my $time_elapsed = $time_resumed - $time_suspended;
    error_message(sprintf("RESUMED AT %s AFTER %s",
                          format_future_time($time_resumed),
                          format_time_interval($time_elapsed)));
    if (defined($time_start))
      { $time_start += $time_elapsed; }
    $time_suspended = undef;
  }
  else
  {
    error_message(sprintf("RESUMED AT %s WITHOUT HAVING BEEN SUSPENDED",
                          format_future_time($time_resumed)));
  }
  return;
};

#-------------------------------------------------------------------------------
# DETERMINE TERMINAL WIDTH

chop(my $TERM_COLS = `tput cols`);
$TERM_COLS =~ m/^\d+$/ or die;
my $MAX_LINE_LEN = $TERM_COLS - 1;

#-------------------------------------------------------------------------------
# PERFORM LINEAR INTERPOLATION

sub lerp ($$$)
{
  my ($t, $x0, $x1) = @_;
  my $x = $x0 + ($t * ($x1 - $x0));
  return $x;
}

#-------------------------------------------------------------------------------
# TABLE OF SI UNITS

my %UNITS_TO_BASE = (
  'B'    => 1,
  'KB'   => 1_000,
  'MB'   => 1_000_000,
  'GB'   => 1_000_000_000,
  'TB'   => 1_000_000_000_000,
  'PB'   => 1_000_000_000_000_000,
  'EB'   => 1_000_000_000_000_000_000,
);

#-------------------------------------------------------------------------------
# FORMAT SIZE WITH AUTOMATICALLY-CHOSEN SI UNIT

sub format_size ($;$;$)
{
  my ($bytes, $no_padding, $value_precision_max) = @_;

  return "-" if !defined($bytes);

  my $units = undef;
     if ($bytes < $UNITS_TO_BASE{KB})  { $units = 'B';  }
  elsif ($bytes < $UNITS_TO_BASE{MB})  { $units = 'KB'; }
  elsif ($bytes < $UNITS_TO_BASE{GB})  { $units = 'MB'; }
  elsif ($bytes < $UNITS_TO_BASE{TB})  { $units = 'GB'; }
  elsif ($bytes < $UNITS_TO_BASE{EB})  { $units = 'TB'; }
  else                                 { $units = 'EB'; }

  my $value = $bytes / $UNITS_TO_BASE{$units};

  my $value_precision = ($value < 10)?   3:
                        ($value < 100)?  2:
                                         1;
  if (defined($value_precision_max) &&
      ($value_precision > $value_precision_max))
    { $value_precision = $value_precision_max; }
  if ($units eq 'B')
    { $value_precision = 0; }

  my $size = sprintf("%5.*f %-*s",
                     $value_precision, $value,
                     2, $units);

  if ($no_padding)
    { $size =~ s/^\s*(.*?)\s*$/$1/; }

  return $size;
}

#-------------------------------------------------------------------------------
# INSERT COMMAS IN NUMERIC STRING

sub commaify_number ($)
{
  my ($x) = @_;

  if ($x >= 1000)
  {
    my $y = ""; if ($x =~ s{(\..*)$}{}) { $y = $1; }
    $x = scalar(reverse($x));
    $x =~ s{(\d{3})(?=\d)}{$1,}g;
    $x = scalar(reverse($x));
    return $x . $y;
  }
  else
  {
    return $x;
  }
}

#-------------------------------------------------------------------------------
# REMOVE COMMAS FROM NUMERIC STRING

sub uncommaify_number ($)
{
  my ($x) = @_;
  $x =~ s/,//g;
  return $x;
}

#-------------------------------------------------------------------------------
# FORMAT FUTURE EPOCH TIME FOR HUMAN VIEWING

sub format_future_time ($)
{
  my ($time_future) = @_;
  $time_future = int($time_future + .5);

  my $time_now = int(get_time() + .5);
  $time_future = $time_now if $time_future < $time_now;
  my $time_delta = $time_future - $time_now;

  my $include_hour    = ($time_delta < 86400*7);
  my $include_minutes = ($time_delta < 86400);
  my $include_seconds = ($time_delta < 30);

  if ($include_hour && !$include_minutes)
    { $time_future += 1800; }  # Round to nearest hour.
  elsif ($include_hour && $include_minutes && !$include_seconds)
    { $time_future += 30; }  # Round to nearest minute.
  $time_delta = $time_future - $time_now;

  my @MONTHS = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);

  my ($sec1, $min1, $hour1, $mday1, $mon1, $year1, $wday1, $yday1, $isdst1) =
    localtime($time_now);
  my ($sec2, $min2, $hour2, $mday2, $mon2, $year2, $wday2, $yday2, $isdst2) =
    localtime($time_future);

  my $same_day = ($year2 == $year1) && ($yday2 == $yday1);
  my $include_year = ($year2 != $year1);
  my $include_month = !$same_day && ($time_delta > 3600*18);
  my $include_day = 1; #($time_delta < 86400*90);

  my @str = ();
  if ($include_hour && !$include_minutes)
  {
    push @str, sprintf("%d%s",
                       (($hour2 + 11) % 12) + 1,
                       ($hour2 < 12? "am":"pm"));
  }
  elsif ($include_hour && $include_minutes && !$include_seconds)
  {
    push @str, sprintf("%d:%02d%s",
                       (($hour2 + 11) % 12) + 1,
                       $min2,
                       ($hour2 < 12? "am":"pm"));
  }
  elsif ($include_hour && $include_minutes && $include_seconds)
  {
    push @str, sprintf("%d:%02d:%02d%s",
                       (($hour2 + 11) % 12) + 1,
                       $min2,
                       $sec2,
                       ($hour2 < 12? "am":"pm"));
  }

  if ($include_month && !$include_day)
  {
    push @str, sprintf("%s", $MONTHS[$mon2]);
  }
  elsif ($include_month && $include_day)
  {
    push @str, sprintf("%s %d", $MONTHS[$mon2], $mday2);
  }

  if ($include_year)
  {
    push @str, sprintf("%d", 1900 + $year2);
  }

  return join(" ", @str);
}

#-------------------------------------------------------------------------------
# FORMAT TIME INTERVAL FOR HUMAN VIEWING

sub format_time_interval ($)
{
  my ($seconds) = @_;

  $seconds = int($seconds + .5) if $seconds >= 9.5;
  $seconds = 0 if $seconds < 0;

  if ($seconds < 10)  # less than 10 seconds
  {
    return sprintf("%.1fs", $seconds);
  }
  elsif ($seconds < 60)  # less than 1 minute
  {
    return sprintf("%us", $seconds);
  }
  elsif ($seconds < 3600)  # less than 1 hour
  {
    my $minutes = int($seconds / 60);
    $seconds %= 60;
    return sprintf("%um %us", $minutes, $seconds);
  }
  elsif ($seconds < 3600*48)  # less than 2 days
  {
    # Round to nearest minute _before_ computing hours, because 3h 59m 45s
    # must round to 4h 0m and not to 3h 60m.
    $seconds = int($seconds / 60 + .5) * 60;
    my $hours = int($seconds / 3600);
    my $minutes = int($seconds / 60) % 60;
    return sprintf("%uh %um", $hours, $minutes);
  }
  elsif ($seconds < 86400*14)  # less than 2 weeks
  {
    # Round to nearest hour _before_ computing days, because 5d 23h 45m
    # must round to 6d 0h and not to 5d 24h.
    $seconds = int($seconds / 3600 + .5) * 3600;
    my $days = int($seconds / 86400);
    my $hours = int($seconds / 3600) % 24;
    return sprintf("%ud %uh", $days, $hours);
  }
  elsif ($seconds < 86400*365.25)  # less than 1 year
  {
    my $days = int(($seconds / 86400) + .5);
    return sprintf("%ud", $days);
  }
  elsif ($seconds < 86400*365.25*5)  # less than 5 years
  {
    my $years = int($seconds / (86400*365.25));
    my $days = int((($seconds - ($years * (86400*365.25))) / 86400) + .5);
    return sprintf("%uy %ud", $years, $days);
  }
  else  # 5 years or more
  {
    my $years = int(($seconds / (86400*365.25)) + .5);
    return sprintf("%uy", $years);
  }
}

#-------------------------------------------------------------------------------
# FORMAT TIME INTERVAL FOR HUMAN VIEWING (OLD VERSION)

sub format_time_interval_old ($)
{
  my ($seconds) = @_;

  $seconds = int($seconds + .5);
  $seconds = 0 if $seconds < 0;

  if ($seconds < 0)
  {
    return sprintf("0:%02d", $seconds);
  }
  elsif ($seconds <  3600)
  {
    return sprintf("%d:%02d", int($seconds / 60),
                              $seconds % 60);
  }
  else
  {
    return sprintf("%d:%02d:%02d", int($seconds / 3600), 
                                   int($seconds / 60) % 60,
                                   $seconds % 60);
  }
}

#-------------------------------------------------------------------------------
# FORMAT PERCENTAGE FOR HUMAN VIEWING

sub format_percentage ($$$)
{
  my ($numerator, $denominator, $precision) = @_;

  my $str;
  if ($denominator == 0)
  {
    $str = "???%";
  }
  elsif ($numerator <= $denominator)
  {
    $str = sprintf("%.*f%%", $precision, $numerator / $denominator * 100);
    if (($str =~ m/^100/) && ($numerator < $denominator))
    {
      $str =~ s/^1//;
      $str =~ s/0/9/g;
    }
  }
  else
  {
    $str = sprintf("%.*f+%%", $precision - 1, 100);
  }
  return $str;
}

#-------------------------------------------------------------------------------
# INTERPRET ITEMIZED CHANGE CODES (CALLED "REASONS" HERE)
 
my %REASON_SYMBOLS =
(
  'A' => undef,  # Special entry for counting all files.

 #'F' => "\x{25CF}",  # Black circle (●)
  'F' => "\x{2022}",  # Bullet (•)

  'M' => "\x{25E6}",  # White bullet (◦)

  'T' => "\x{00B7}",  # Middle dot (·)

  'D' => "\x{2A09}",  # N-ary times operator (⨉)
 #'D' => "\x{00D7}",  # Multiplication sign (×)
 #'D' => "\x{2298}",  # Circled division slash (⊘)

  '?' => "\x{003F}",  # Question mark (?);
);

sub reason_is_transfer ($)   { return ($_[0] =~ m/^[<>ch]/); }
sub reason_is_dirtime ($)    { return ($_[0] =~ m/^\.d\.{2}t\.{7}/); }
sub reason_is_metadata ($)   { return ($_[0] =~ m/^\./); }
sub reason_is_delete ($)     { return ($_[0] =~ m/^\*deleting/); }

sub reason_code ($)
{
  my ($reason) = @_;

  return  reason_is_transfer($reason)?   'F':
          reason_is_dirtime($reason)?    'T':
          reason_is_metadata($reason)?   'M':
          reason_is_delete($reason)?     'D':
                                         '?';
}

sub format_reason ($)
{
  my ($reason) = @_;

  return $REASON_SYMBOLS{reason_code($reason)};
}

#-------------------------------------------------------------------------------
# FORMAT COUNTS FOR SUMMARY

sub format_counts ($;$)
{
  my ($counts, $include_zeros) = @_;

  my @str;
  for my $reason_code (qw(T M F D))
  {
    if (($counts->{$reason_code} > 0) || $include_zeros)
    {
      push @str, sprintf("%s %s",
                         $REASON_SYMBOLS{$reason_code},
                         commaify_number($counts->{$reason_code}));
    }
  }
  my $str = join("  ", @str);

  return $str;
}

#-------------------------------------------------------------------------------
# FORMAT SUMMARY

sub format_summary ($$$;$)
{
  my ($transferred_bytes, $total_bytes, $counts, $time_elapsed) = @_;

  my $line = "";

  $line .= sprintf("%s", format_size($transferred_bytes, 1));
  if ($transferred_bytes < $total_bytes)
    { $line .= sprintf(" (of %s)", format_size($total_bytes, 1)); }

  my $active_count = $counts->{T} + $counts->{M} + $counts->{F} + $counts->{D};
  my $total_count = $counts->{A};
  $line .= sprintf(" in %s", commaify_number($active_count));
  if ($active_count == 1)
    { $line .= " item"; }
  if ($active_count < $total_count)
    { $line .= sprintf(" (of %s)", commaify_number($total_count)); }
  if ($active_count > 1)
    { $line .= " items"; }

  if (defined($time_elapsed))
  {
    my $overall_speed = $transferred_bytes / ($time_elapsed || 1);

    $line .= sprintf(" in %s", format_time_interval($time_elapsed));

    if ($time_elapsed >= 1)
      { $line .= sprintf(" (%s/s)", format_size($overall_speed, 1, 1)); }
  }

  if ($active_count > 0)
    { $line .= sprintf(":  %s", format_counts($counts)); }

  if (length($line) > $MAX_LINE_LEN)
    { $line =~ s/:  /:\n  /; }

  return $line;
}

#-------------------------------------------------------------------------------
# ENCODE STRING SAFELY FOR USE ON COMMAND LINE IN SHELL

sub shellify ($)
{
  my ($path) = @_;

  if ($path =~ m{^[A-Za-z0-9\_\-\+\=\.\,\/]+$})
  {
    # Simple filename; no changes needed.
  }
  else
  {
    # Enclose the filename in single-quotes, first escaping any existing
    # single-quotes.
    $path =~ s{'}{'\\''}g;
    $path = qq{'$path'};
  }

  return $path;
}

#-------------------------------------------------------------------------------
# OPEN RSYNC STREAM

sub open_rsync_context ($@)
{
  my ($mode, @command_line) = @_;

  use FileHandle;

  if ($mode eq 'PREP')
  {
    splice @command_line, 1, 0,
           "--dry-run",
           "--itemize-changes",
           "--stats";
  }
  elsif ($mode eq 'SYNC')
  {
    splice @command_line, 1, 0,
           "--verbose",
           "--itemize-changes",
           "--progress",
           "--stats";
  }
  else
  {
    die;
  }

  my $command_line = join(" ", map { shellify($_) } @command_line);
  debug_message("+ $command_line");
  
  my $stream;
  if ($stream = FileHandle->new("$command_line |"))
  {
    $stream->binmode(':utf8');
  }
  else
  {
    error_message_exit("Couldn't invoke rsync");
  }

  my $context =
  {
    MODE      => $mode,
    COMMAND   => $command_line,
    STREAM    => $stream,
  };

  return $context;
}

#-------------------------------------------------------------------------------
# CLOSE RSYNC STREAM

sub close_rsync_context ($)
{
  my ($context) = @_;

  if (!$context->{STREAM}->eof())
    { error_message_exit("rsync input stream closed prematurely"); }

  $context->{STREAM}->close();

  return;
}

#-------------------------------------------------------------------------------
# READ LINE FROM RSYNC STREAM
#
# This routine reads one character at a time, rather than whole lines.  The
# reason for this insanity is because Perl's input record separator variable
# ($/) is a plain old string rather than a regular expression, and this program
# needs to be able to handle either \r or \n as valid end-of-line characters.

sub read_rsync_line ($)
{
  my ($context) = @_;

  if ($HALT_REQUESTED)
  {
    error_message("\nCLEANING UP...");
    $context->{STREAM}->close();
    sleep(5);
    exit 1;
  }

  return undef if $context->{STREAM}->eof();

  my $line = "";

  undef $!;

  while (defined(my $char = $context->{STREAM}->getc()))
  {
    my $eol = ($char =~ m/^[\r\n]$/);
    if ($eol) { debug_message("RSYNC: $line", 1); }
    $line .= $char;
    last if $eol;
  }

  if ($!)
    { error_message_exit("ERROR $!"); }

  return $line;
}

#-------------------------------------------------------------------------------
# PERFORM PREPARATION PASS WITH RSYNC

sub preparation_pass (@)
{
  my (@command_line) = @_;

  my $counts = { A => 0, F => 0, M => 0, T => 0, D => 0, '?' => 0 };
  my $total_bytes = 0;
  my $transferred_bytes = 0;

  my $context = open_rsync_context('PREP', @command_line);
  while (defined(my $line = read_rsync_line($context)))
  {
    if ($line =~ m/^Number of files:\s+([0-9,]+)/)
    {
      $counts->{A} = uncommaify_number($1);
    }
    elsif ($line =~ m/^Total file size: ([0-9,]+) bytes/)
    {
      $total_bytes = uncommaify_number($1);
    }
    elsif ($line =~ m/^Total transferred file size: ([0-9,]+) bytes/)
    {
      $transferred_bytes = uncommaify_number($1);
    }
    if ($line =~ m/^(\S{12}|\*deleting)\s+(.*)$/)
    {
      my ($reason, $path) = ($1, $2);
      $counts->{reason_code($reason)}++;
      if ($DRY_RUN_MODE && $ITEMIZE_MODE && !$COMPARISON_MODE)
        { printf "%s %s\n", format_reason($reason), $path; }
    }
  }
  close_rsync_context($context);

  return ($counts, $total_bytes, $transferred_bytes);
}

#-------------------------------------------------------------------------------
# READ EVENT FROM RSYNC STREAM

sub read_rsync_event ($)
{
  my ($context) = @_;

  while (defined(my $line = read_rsync_line($context)))
  {
    if ($line =~ m/^(\S{12}) (.*)$/)
    {
      my ($reason, $path) = ($1, $2);
      return { TYPE => 'ITEM', REASON => $reason, PATH => $path,
               TRANSFERRING => ($reason =~ m/^.f/? 1:0),
               UPDATING => ($reason !~ m/^.f/? 1:0),
               DELETING => 0 };
    }
    elsif ($line =~ m/^(\*deleting)\s+(.*)$/)
    {
      my ($reason, $path) = ($1, $2);
      return { TYPE => 'ITEM', REASON => $reason, PATH => $path,
               TRANSFERRING => 0, UPDATING => 0, DELETING => 1 };
    }
    elsif ($line =~ m{^\s*([0-9,]+)\s+([0-9\.]+%)\s+([0-9\.,]+[A-Za-z]?B/s)\s+})
    {
      my ($bytes, $percent, $speed) = ($1, $2, $3);
      $bytes = uncommaify_number($bytes);
      my $is_complete = 0;
      if ($percent =~ m/^100/)
      {
        if ($line =~ m/\(xfr#\d+/)
        {
          # Completeness is only known with certainty when the "xfr" portion
          # appears.  It is not safe to trust the percentage alone, in case of
          # rounding, i.e., 99.7% rounding to 100%.
          $is_complete = 1;
        }
        else
        {
          # If not ACTUALLY complete, change 100% to 99%, 100.0% to 99.9%, etc.
          $percent =~ s/1//;
          $percent =~ s/0/9/g;
        }
      }
      $speed =~ s{kB}{KB};
      $speed =~ s{^([0-9,\.]+)}{$1 };

      return { TYPE => 'PROGRESS', BYTES => $bytes, PERCENT => $percent,
               COMPLETE => $is_complete, SPEED => $speed };
    }
  }

  return undef;  # Signifies end of file.
}

#-------------------------------------------------------------------------------
# PERFORM SYNCHRONIZATION PASS WITH RSYNC

sub synchronization_pass ($$@)
{
  my ($expected_counts, $expected_bytes, @command_line) = @_;

  my $counts = { A => 0, F => 0, M => 0, T => 0, D => 0, '?' => 0 };
  my $bytes = 0;

  my $items_width = length(commaify_number($expected_counts->{F}));
  my $total_items_width = length(commaify_number($expected_counts->{A}));
  my $bytes_width = length(format_size($expected_bytes));

  #my $time_start = undef;
  $time_start = undef;  # Note that this variable is global because of signals.

  my $prev_line = "";
  my $prev_time_total = undef;
  my $prev_speed = undef;

  my $context = open_rsync_context('SYNC', @command_line);
  while (defined(my $event = read_rsync_event($context)))
  {
    if (!defined($time_start))
      { $time_start = get_time(); }

    if ($event->{TYPE} eq 'ITEM')
    {
      $counts->{reason_code($event->{REASON})}++;

      if ($ITEMIZE_MODE)
      {
        if ($PROGRESS_MODE && !$DEBUG_MODE)
          { printf "%s\r", " " x length($prev_line); }
        printf "%s %s\n", format_reason($event->{REASON}), $event->{PATH};
        if ($PROGRESS_MODE && !$DEBUG_MODE)
          { printf "%s\r", $prev_line; }  # FIXME: Regenerate with new count.
      }
    }
    elsif ($event->{TYPE} eq 'PROGRESS')
    {
      my $tb = $bytes + $event->{BYTES};

      my $time_elapsed = get_time() - $time_start;
      my $display_time_remaining = ($time_elapsed >= 5);
      my $time_total = $time_elapsed / (($tb / ($expected_bytes||1)) || 1);
      if (defined($prev_time_total) && $display_time_remaining)
      {
        $time_total = lerp(($time_total > $prev_time_total? 0.01 : 0.25),
                           $prev_time_total,
                           $time_total);
        #$time_total = lerp(10/(10+$time_elapsed),
        #                   $prev_time_total, $time_total);
      }
      $prev_time_total = $time_total;
      my $time_remaining = $time_total - $time_elapsed;

      my $speed = $tb / ($time_elapsed||1);
      if (defined($prev_speed))
        { $speed = lerp(10/(10+$time_elapsed), $prev_speed, $speed); }
      $prev_speed = $speed;

      my $show_percent = ($event->{PERCENT} ne "100%") &&
                         ($event->{PERCENT} ne "0%");

      my $line = sprintf("%7s %*s of %-*s",
                         ($show_percent? "$event->{PERCENT} of" : ""),
                         $items_width,
                         commaify_number($counts->{T} +
                                         $counts->{M} +
                                         $counts->{F} +
                                         $counts->{D}),
                         $items_width,
                         commaify_number($expected_counts->{T} +
                                         $expected_counts->{M} +
                                         $expected_counts->{F} +
                                         $expected_counts->{D}));
      if (0 && ($expected_counts->{F} != $expected_counts->{A}))
      {
        $line .= sprintf(" of %-*s",
                         $total_items_width,
                         commaify_number($expected_counts->{A}));
      }

      $line .= sprintf(
        "  %7s of %-*s  %11s   %s%s",
        format_percentage($tb, $expected_bytes, 2),
        $bytes_width, format_size($expected_bytes),
        format_size($speed, 1, 1) . "/s",
        $display_time_remaining
          ? format_future_time($time_start + $time_total) : "",
        $display_time_remaining
            ? sprintf(" (%s)", format_time_interval($time_remaining)) : ""
      );

      if (length($line) > $MAX_LINE_LEN)
      {
        $line =~ s{\s*\(.*?\)$}{};   # KLUDGE: Remove time remaining.

        if (length($line) > $MAX_LINE_LEN)
          { $line = substr($line, 0, $MAX_LINE_LEN); }
      }

      if ($PROGRESS_MODE)
      {
        printf "%s%s%s",
               $line,
               " " x (length($prev_line) > length($line)?
                      length($prev_line) - length($line) : 0),
               $DEBUG_MODE? "\n" : "\r";
      }
      $prev_line = $line;

      if ($event->{COMPLETE})
        { $bytes += $event->{BYTES}; }
    }
  }
  close_rsync_context($context);

  if (!defined($time_start))
    { $time_start = get_time(); }

  my $time_end = get_time();
  my $time_elapsed = $time_end - $time_start;

  if ($PROGRESS_MODE)
    { printf "%s\r", " " x length($prev_line); }

  return ($counts, $bytes, $time_elapsed);
}

#-------------------------------------------------------------------------------
# MAIN CONTROL

# --- Extract relevant command-line options, leaving others in place.

use Getopt::Long qw(:config pass_through bundling);
Getopt::Long::GetOptions(
  "compare-only!"        => \$COMPARISON_MODE,
  "dry-run!"             => \$DRY_RUN_MODE,
  "n"                    => \$DRY_RUN_MODE,
  "itemize-changes!"     => \$ITEMIZE_MODE,
  "verbose!"             => \$VERBOSE_MODE,
  "v"                    => \$VERBOSE_MODE,
  "progress!"            => \$PROGRESS_MODE,
  "summary!"             => \$SUMMARY_MODE,
  "debug!"               => \$DEBUG_MODE,
  "local-rsync-path=s"   => \$LOCAL_RSYNC_PATH,
  "remote-rsync-path=s"  => \$REMOTE_RSYNC_PATH,
) or exit(1);

# --- Dump debugging information.

debug_message("DEBUG_MODE      = $DEBUG_MODE");
debug_message("COMPARISON_MODE = $COMPARISON_MODE");
debug_message("DRY_RUN_MODE    = $DRY_RUN_MODE");
debug_message("VERBOSE_MODE    = $VERBOSE_MODE");
debug_message("ITEMIZE_MODE    = $ITEMIZE_MODE");
debug_message("PROGRESS_MODE   = $PROGRESS_MODE");
debug_message("SUMMARY_MODE    = $SUMMARY_MODE");

# --- Construct the rsync command line.

my @command_line = grep { defined }
(
  $LOCAL_RSYNC_PATH,
  (defined($REMOTE_RSYNC_PATH)
    ? sprintf("--rsync-path=%s", shellify($REMOTE_RSYNC_PATH))
    : undef),
  @ARGV
);

# --- Execute preparation pass.

my ($counts, $total_bytes, $transferred_bytes) =
  preparation_pass(@command_line);

my $time_elapsed = undef;

my $change_count = $counts->{T} + $counts->{M} + $counts->{F} + $counts->{D};

if ($COMPARISON_MODE)
{
  my $exit_value = ($change_count == 0)?  0 : 1;
  debug_message("Exiting with value $exit_value");
  exit $exit_value;
}

# --- Execute syncronization pass.

if (!$DRY_RUN_MODE)
{
  my $old_counts = $counts;  # FIXME

  ($counts, $transferred_bytes, $time_elapsed) =
    synchronization_pass($counts, $transferred_bytes, @command_line);

  $counts->{A} = $old_counts->{A};  # FIXME
}

# --- Print summary.

if ($SUMMARY_MODE)
{
  if ($change_count == 0)
  {
    print "No changes\n";
  }
  else
  {
    printf "%s\n",
      format_summary($transferred_bytes, $total_bytes, $counts, $time_elapsed);
  }
}


# TODO:  If apparently successful, and some command-line option is set
# (maybe --validate or something?) then run rsync one more time to
# verify that there are no more changes, and report failure if the
# source and target still differ.
#
